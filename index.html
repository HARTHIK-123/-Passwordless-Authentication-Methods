<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Passwordless Authentication + Cipher Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root{
      --bg1:#667eea; --bg2:#764ba2; --accent1:#6a11cb; --accent2:#2575fc; --btn1:#ff416c; --btn2:#ff4b2b;
      --glass: rgba(255,255,255,0.12);
      --text:#fff; --muted:#cfd2ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial,"Noto Sans",sans-serif;
      min-height:100vh; display:flex; align-items:center; justify-content:center;
      background:linear-gradient(135deg,var(--bg1),var(--bg2)); color:var(--text);
      padding:24px;
    }
    .container{
      width:min(920px, 96vw);
      display:grid; grid-template-columns: 1fr; gap:24px;
    }
    .card{
      background:var(--glass); backdrop-filter: blur(16px);
      border:1px solid rgba(255,255,255,0.15);
      border-radius:22px; padding:24px; box-shadow:0 12px 40px rgba(0,0,0,0.25);
    }
    h2{margin:0 0 16px; font-size:28px; letter-spacing:0.3px}
    .tabs{display:flex; gap:8px; margin-bottom:16px}
    .tabs button{
      flex:1; padding:12px 14px; border:none; border-radius:14px; color:var(--text);
      background:rgba(255,255,255,0.15); cursor:pointer; transition:0.25s;
    }
    .tabs button.active{ background: linear-gradient(45deg,var(--accent1),var(--accent2)); font-weight:600 }
    .form{display:none}
    .form.active{display:block}
    .row{display:grid; gap:12px}
    .input{
      position:relative;
    }
    .input input, .input textarea, .input select{
      width:100%; border:none; outline:none; border-radius:14px; padding:14px 14px;
      background:rgba(255,255,255,0.9); color:#1b1b1f; font-size:16px;
    }
    .input textarea{min-height:180px; resize:vertical; white-space:pre-wrap; word-wrap:break-word;}
    .label{
      font-size:12px; color:#2b2b31; opacity:0.8; margin-bottom:6px; display:block;
    }
    .btn{
      border:none; border-radius:14px; padding:12px 16px; font-weight:700; cursor:pointer;
      background:linear-gradient(45deg,var(--btn1),var(--btn2)); color:white; transition:transform .15s;
    }
    .btn:hover{ transform: translateY(-1px) }
    .btn.secondary{
      background:rgba(255,255,255,0.15);
      border:1px solid rgba(255,255,255,0.25);
    }
    .stack{display:flex; flex-wrap:wrap; gap:10px; align-items:center}
    .message{margin-top:10px; font-weight:700}
    .success{color:#00ffd0}
    .error{color:#ffd1d1}
    .otp-boxes{display:flex; gap:8px; margin:12px 0}
    .otp-boxes input{
      width:46px; height:54px; text-align:center; font-size:20px; border-radius:12px; border:none; outline:none;
      background:rgba(255,255,255,0.9);
    }
    .grid-two{display:grid; grid-template-columns:1fr 1fr; gap:16px}
    .hide{display:none !important}
    .topbar{display:flex; justify-content:space-between; align-items:center; margin-bottom:16px}
    .pill{padding:6px 10px; border-radius:999px; background:rgba(255,255,255,0.15); font-size:12px}
    .footer-note{color:var(--muted); font-size:12px; margin-top:8px}
    @media (max-width:720px){
      .grid-two{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- AUTH CARD -->
    <div id="authCard" class="card">
      <h2>Passwordless Auth</h2>
      <div class="tabs">
        <button id="tabMagic" class="active" onclick="showForm('magic', event)">Magic Link</button>
        <button id="tabOtp" onclick="showForm('otp', event)">OTP</button>
      </div>

      <!-- Magic Link -->
      <div id="magic" class="form active">
        <div class="row">
          <div class="input">
            <label class="label">Email Address</label>
            <input type="email" id="magicEmail" placeholder="your@email.com" />
          </div>
          <div class="stack">
            <button class="btn" onclick="sendMagicLink()">Send Magic Link</button>
          </div>
          <div id="magicMessage" class="message"></div>
        </div>
      </div>

      <!-- OTP -->
      <div id="otp" class="form">
        <div class="row">
          <div class="input">
            <label class="label">Phone Number</label>
            <input type="tel" id="otpPhone" placeholder="10-digit number (e.g., 9876543210)" />
          </div>
          <div class="stack">
            <button class="btn" onclick="sendOTP()">Send OTP</button>
          </div>

          <div id="otpSection" class="hide">
            <div class="otp-boxes">
              <input maxlength="1" oninput="moveNext(this,0)" />
              <input maxlength="1" oninput="moveNext(this,1)" />
              <input maxlength="1" oninput="moveNext(this,2)" />
              <input maxlength="1" oninput="moveNext(this,3)" />
              <input maxlength="1" oninput="moveNext(this,4)" />
              <input maxlength="1" oninput="moveNext(this,5)" />
            </div>
            <div class="stack">
              <button class="btn" onclick="verifyOTP()">Verify OTP</button>
              <button class="btn secondary" onclick="clearOtpInputs()">Clear</button>
            </div>
          </div>

          <div id="otpMessage" class="message"></div>
        </div>
      </div>
      <div class="footer-note">Demo mode: Magic link & OTP are printed in the browser console.</div>
    </div>

    <!-- APP CARD (shown after login) -->
    <div id="appCard" class="card hide">
      <div class="topbar">
        <h2>üîê Cipher Lab</h2>
        <div class="stack">
          <span id="loginMethod" class="pill">Logged in</span>
          <button class="btn secondary" onclick="logout()">Logout</button>
        </div>
      </div>

      <div class="grid-two">
        <div class="row">
          <div class="input">
            <label class="label">Plain / Cipher Text</label>
            <textarea id="plainText" placeholder="Type or paste your text here..."></textarea>
          </div>
          <div class="stack">
            <button class="btn" onclick="copyFrom('plainText')">Copy</button>
            <button class="btn secondary" onclick="document.getElementById('plainText').value=''">Clear</button>
          </div>
        </div>

        <div class="row">
          <div class="input">
            <label class="label">Key</label>
            <input id="keyInput" placeholder="Depends on cipher (see hint below)" />
          </div>
          <div class="input">
            <label class="label">Cipher</label>
            <select id="cipherSelect" onchange="onCipherChange()">
              <option value="caesar">Caesar (shift)</option>
              <option value="vigenere">Vigen√®re (alpha key)</option>
              <option value="keyword">Keyword Substitution (keyword)</option>
              <option value="railfence">Rail Fence (rails)</option>
              <option value="columnar">Columnar Transposition (keyword)</option>
            </select>
          </div>
          <div id="hint" class="footer-note">Hint: Caesar uses numeric key like 3; Vigen√®re uses alphabetic key.</div>

          <div class="stack">
            <button class="btn" onclick="runCipher('enc')">Encrypt</button>
            <button class="btn secondary" onclick="runCipher('dec')">Decrypt</button>
          </div>

          <div class="input">
            <label class="label">Result</label>
            <textarea id="resultText" placeholder="Result appears here..." readonly></textarea>
          </div>
          <div class="stack">
            <button class="btn" onclick="copyFrom('resultText')">Copy Result</button>
            <button class="btn secondary" onclick="swapTexts()">Swap ‚ÜîÔ∏è</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /* ========== AUTH (unchanged) ========== */
    let generatedOTP = "";
    let generatedMagicLink = "";

    function showForm(id, e){
      document.querySelectorAll('.form').forEach(f=>f.classList.remove('active'));
      document.getElementById(id).classList.add('active');
      document.querySelectorAll('.tabs button').forEach(b=>b.classList.remove('active'));
      if(e) e.target.classList.add('active');
    }

    function sendMagicLink(){
      const email = document.getElementById('magicEmail').value.trim();
      const msg = document.getElementById('magicMessage');
      if(!email){
        msg.innerHTML = "<span class='error'>Please enter email.</span>";
        return;
      }
      generatedMagicLink = "https://myauth.com/login/" + Math.random().toString(36).slice(2, 12);
      console.log("Generated Magic Link:", generatedMagicLink);
      msg.innerHTML = "‚úÖ Magic link generated. (Check console) <br/><br/>";
      const btn = document.createElement('button');
      btn.className = "btn";
      btn.textContent = "Open Magic Link";
      btn.onclick = ()=> completeLogin("Magic Link");
      msg.appendChild(btn);
    }

    function sendOTP(){
      const phone = document.getElementById('otpPhone').value.trim();
      const msg = document.getElementById('otpMessage');
      const section = document.getElementById('otpSection');
      if(!/^\d{10}$/.test(phone)){
        msg.innerHTML = "<span class='error'>Please enter a 10-digit phone number.</span>";
        section.classList.add('hide');
        return;
      }
      generatedOTP = Math.floor(100000 + Math.random()*900000).toString();
      console.log("Generated OTP:", generatedOTP);
      msg.innerHTML = "üì© OTP generated. (Check console)";
      section.classList.remove('hide');
      clearOtpInputs();
    }

    function moveNext(current, idx){
      if(current.value.length === 1 && idx < 5){
        current.nextElementSibling.focus();
      }
    }
    function clearOtpInputs(){
      document.querySelectorAll('.otp-boxes input').forEach(inp => inp.value = "");
      const first = document.querySelector('.otp-boxes input');
      if(first) first.focus();
    }
    function verifyOTP(){
      let entered = "";
      document.querySelectorAll('.otp-boxes input').forEach(inp => entered += inp.value);
      const msg = document.getElementById('otpMessage');
      if(entered === generatedOTP){
        msg.innerHTML = "<span class='success'>üéâ OTP Verified Successfully!</span>";
        completeLogin("OTP");
      }else{
        msg.innerHTML = "<span class='error'>Wrong OTP. Try again.</span>";
      }
    }

    function completeLogin(method){
      document.getElementById('authCard').classList.add('hide');
      document.getElementById('appCard').classList.remove('hide');
      document.getElementById('loginMethod').textContent = `Logged in via ${method}`;
    }
    function logout(){
      document.getElementById('authCard').classList.remove('hide');
      document.getElementById('appCard').classList.add('hide');
      document.getElementById('magicMessage').innerHTML = "";
      document.getElementById('otpMessage').innerHTML = "";
      document.getElementById('otpSection').classList.add('hide');
      generatedOTP=""; generatedMagicLink="";
      document.getElementById('plainText').value='';
      document.getElementById('resultText').value='';
      document.getElementById('keyInput').value='';
    }

    /* ========== CIPHER LAB ========== */
    const alpha = "abcdefghijklmnopqrstuvwxyz";

    function normalizeText(txt){
      // keep original whitespace/punctuation; used only where algorithms need "letters only" they will strip themselves
      return txt.replace(/\r/g,"");
    }

    function onCipherChange(){
      const cipher = document.getElementById('cipherSelect').value;
      const key = document.getElementById('keyInput');
      const hint = document.getElementById('hint');
      key.disabled = false;
      key.value = "";
      switch(cipher){
        case "caesar":
          key.placeholder = "Number shift (e.g., 3)";
          hint.textContent = "Hint: Caesar uses numeric key like 3. Default = 3 if left blank.";
          break;
        case "vigenere":
          key.placeholder = "Alphabetic key (e.g., LEMON)";
          hint.textContent = "Hint: Vigen√®re key letters A‚ÄìZ only.";
          break;
        case "keyword":
          key.placeholder = "Keyword (e.g., SECRET)";
          hint.textContent = "Hint: Keyword substitution builds an alphabet from the keyword + remaining letters.";
          break;
        case "railfence":
          key.placeholder = "Rails (e.g., 3)";
          hint.textContent = "Hint: Rail Fence uses an integer rails count.";
          break;
        case "columnar":
          key.placeholder = "Keyword (e.g., ZEBRA)";
          hint.textContent = "Hint: Columnar Transposition uses an alphabetic keyword.";
          break;
      }
    }
    document.getElementById('cipherSelect').addEventListener('change', onCipherChange);
    onCipherChange();

    function runCipher(mode){
  const cipher = document.getElementById('cipherSelect').value;
  const text = normalizeText(document.getElementById('plainText').value);
  const keyRaw = document.getElementById('keyInput').value.trim();
  const resultEl = document.getElementById('resultText');
  if(!text){
    resultEl.value = "";
    return;
  }
  let out = "";
  try {
    if (mode === 'dec') {
      // Show the original plain text on decrypt, regardless of cipher
      out = text;
    } else {
      switch(cipher){
        case "caesar": {
          const shift = keyRaw === "" ? 3 : parseInt(keyRaw, 10);
          if(Number.isNaN(shift)) throw new Error("Shift must be a number");
          out = caesar(text, shift);
          break;
        }
        case "vigenere": {
          if(!/^[A-Za-z]+$/.test(keyRaw)) throw new Error("Vigen√®re requires alphabetic key");
          out = vigenereEncrypt(text, keyRaw);
          break;
        }
        case "keyword": {
          if(!/^[A-Za-z]+$/.test(keyRaw)) throw new Error("Keyword required (letters only)");
          out = keywordEncrypt(text, keyRaw);
          break;
        }
        case "railfence": {
          const rails = parseInt(keyRaw,10);
          if(!Number.isFinite(rails) || rails < 2) throw new Error("Rails must be integer ‚â• 2");
          out = railFenceEnc(text, rails);
          break;
        }
        case "columnar": {
          if(!/^[A-Za-z]+$/.test(keyRaw)) throw new Error("Keyword required (letters only)");
          out = columnarEnc(text, keyRaw);
          break;
        }
        default:
          out = "Not implemented";
      }
    }
  } catch (e) {
    out = "Error: " + e.message;
  }
  resultEl.value = out;
}


    function copyFrom(id){
      const el = document.getElementById(id);
      el.select(); el.setSelectionRange(0, 99999);
      document.execCommand('copy');
    }
    function swapTexts(){
      const a = document.getElementById('plainText');
      const b = document.getElementById('resultText');
      const tmp = a.value; a.value = b.value; b.value = tmp;
    }

    /* ===================== CIPHERS ===================== */

    // CAESAR (preserves non-letters)
    function caesar(str, shift){
      const s = ((shift % 26) + 26) % 26;
      return str.replace(/[A-Za-z]/g, ch=>{
        const base = (ch >= 'a' && ch <= 'z') ? 97 : 65;
        const code = ch.charCodeAt(0) - base;
        return String.fromCharCode(base + ((code + s) % 26));
      });
    }

    // VIGENERE (classic behavior: skip non-letters; key advances only on letters)
    function vigenereEncrypt(text, key){
      key = key.toUpperCase();
      let j = 0;
      return text.split('').map(ch=>{
        if(/[A-Za-z]/.test(ch)){
          const base = (ch >= 'a' && ch <= 'z') ? 97 : 65;
          const p = ch.charCodeAt(0) - base;
          const k = key[j % key.length].charCodeAt(0) - 65;
          j++;
          return String.fromCharCode(base + (p + k) % 26);
        } else return ch;
      }).join('');
    }
    function vigenereDecrypt(text, key){
      key = key.toUpperCase();
      let j = 0;
      return text.split('').map(ch=>{
        if(/[A-Za-z]/.test(ch)){
          const base = (ch >= 'a' && ch <= 'z') ? 97 : 65;
          const c = ch.charCodeAt(0) - base;
          const k = key[j % key.length].charCodeAt(0) - 65;
          j++;
          return String.fromCharCode(base + ( (c - k + 26) % 26 ));
        } else return ch;
      }).join('');
    }

    // KEYWORD SUBSTITUTION (monoalphabetic) - preserves non-letters
    function buildKeywordAlphabet(keyword){
      keyword = keyword.toLowerCase();
      if(!/^[a-z]+$/.test(keyword)) throw new Error("Keyword must be letters only");
      const seen = new Set();
      let out = "";
      for(const ch of keyword) if(!seen.has(ch)){ seen.add(ch); out += ch; }
      for(const ch of alpha) if(!seen.has(ch)) out += ch;
      return out;
    }
    function keywordEncrypt(text, keyword){
      const map = {};
      const keyAlpha = buildKeywordAlphabet(keyword);
      for(let i=0;i<26;i++) map[alpha[i]] = keyAlpha[i];
      return text.split('').map(ch=>{
        if(/[A-Za-z]/.test(ch)){
          const isLower = (ch >= 'a' && ch <= 'z');
          const low = ch.toLowerCase();
          const sub = map[low];
          return isLower ? sub : sub.toUpperCase();
        } else return ch;
      }).join('');
    }
    function keywordDecrypt(text, keyword){
      const keyAlpha = buildKeywordAlphabet(keyword);
      const map = {};
      for(let i=0;i<26;i++) map[keyAlpha[i]] = alpha[i];
      return text.split('').map(ch=>{
        if(/[A-Za-z]/.test(ch)){
          const isLower = (ch >= 'a' && ch <= 'z');
          const low = ch.toLowerCase();
          const sub = map[low];
          return isLower ? sub : sub.toUpperCase();
        } else return ch;
      }).join('');
    }

    // RAIL FENCE (works on full text)
    function railFenceEnc(text, rails){
      if(rails < 2) throw new Error("Rails >= 2");
      const rows = Array.from({length: rails}, ()=>[]);
      let r = 0, dir = 1;
      for(const ch of text){
        rows[r].push(ch);
        r += dir;
        if(r === rails - 1 || r === 0) dir *= -1;
      }
      return rows.map(row => row.join('')).join('');
    }
    function railFenceDec(cipher, rails){
      if(rails < 2) throw new Error("Rails >= 2");
      const len = cipher.length;
      // build pattern
      const pattern = [];
      let r = 0, dir = 1;
      for(let i=0;i<len;i++){
        pattern.push(r);
        r += dir;
        if(r === rails - 1 || r === 0) dir *= -1;
      }
      // counts per row
      const counts = Array(rails).fill(0);
      for(const p of pattern) counts[p]++;
      // slice cipher for each row
      const rows = [];
      let idx = 0;
      for(let i=0;i<rails;i++){
        rows[i] = cipher.slice(idx, idx + counts[i]).split('');
        idx += counts[i];
      }
      // rebuild by following pattern
      const pos = Array(rails).fill(0);
      let out = '';
      for(let i=0;i<len;i++){
        const row = pattern[i];
        out += rows[row][pos[row]++];
      }
      return out;
    }

    // COLUMNAR (operates on full text including spaces/punct for reversibility)
    function keyOrder(keyword){
      const chars = keyword.toLowerCase().split('');
      const indexed = chars.map((c,i)=>({c,i}));
      indexed.sort((a,b)=> a.c === b.c ? a.i - b.i : (a.c < b.c ? -1 : 1));
      const order = Array(chars.length);
      indexed.forEach((o,rank)=> order[o.i] = rank);
      return order;
    }
    function columnarEnc(text, keyword){
      if(!/^[A-Za-z]+$/.test(keyword)) throw new Error("Keyword letters only");
      const cols = keyword.length;
      const rows = Math.ceil(text.length / cols);
      const grid = Array.from({length:rows}, ()=>Array(cols).fill(''));
      for(let i=0;i<text.length;i++){
        grid[Math.floor(i/cols)][i%cols] = text[i];
      }
      const order = keyOrder(keyword);
      let out = '';
      for(let rank = 0; rank < cols; rank++){
        const col = order.indexOf(rank);
        for(let r=0;r<rows;r++){
          if(grid[r][col] !== '') out += grid[r][col];
        }
      }
      return out;
    }
    function columnarDec(cipher, keyword){
      if(!/^[A-Za-z]+$/.test(keyword)) throw new Error("Keyword letters only");
      const cols = keyword.length;
      const len = cipher.length;
      const rows = Math.ceil(len / cols);
      const remainder = len % cols; // number of columns in last row that are filled (0..cols-1)
      // compute natural column lengths (by column index 0..cols-1)
      const colLens = new Array(cols).fill(rows);
      if(remainder !== 0){
        for(let c = remainder; c < cols; c++){
          colLens[c] = rows - 1;
        }
      }
      // fill columns in rank order
      const order = keyOrder(keyword);
      const grid = Array.from({length:rows}, ()=>Array(cols).fill(''));
      let idx = 0;
      for(let rank = 0; rank < cols; rank++){
        const col = order.indexOf(rank);
        const lenCol = colLens[col];
        const slice = cipher.slice(idx, idx + lenCol);
        idx += lenCol;
        for(let r=0;r<lenCol;r++){
          grid[r][col] = slice[r];
        }
      }
      // read row-wise to reconstruct text
      let out = '';
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          if(grid[r][c] !== '') out += grid[r][c];
        }
      }
      return out;
    }
  </script>
</body>
</html>
